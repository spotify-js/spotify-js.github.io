<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>managers/Playlist.js</title>
		<link rel="icon" type="image/x-icon" href="favicon.ico"/>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
			<style>
				.page-header,
				pre.code-toolbar > .toolbar:hover {
					background-color: #3cb733;
				}
				.callout-primary,
				.toc .nav > li > a:hover,
				.toc .nav > li > a:focus,
				.toc .nav > li.active > a,
				.toc .nav > li.active > a:hover,
				.toc .nav > li.active > a:focus,
				pre.code-toolbar > .toolbar:hover {
					border-left-color: #3cb733;
				}
				pre.code-toolbar > .toolbar:hover {
					border-bottom-color: #3cb733;
				}
				.callout-primary h5,
				.symbol-title.collapsible-symbol .toggle-icon,
				.breadcrumb li a,
				.toc .nav > li > a:hover,
				.toc .nav > li > a:focus,
				.toc .nav > li.active > a,
				.toc .nav > li.active > a:hover,
				.toc .nav > li.active > a:focus {
					color: #3cb733;
				}
			</style>
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"Spotify Library.js","systemSummary":"A library for interacting with spotify's API.","systemLogo":"img/logo.png","systemColor":"#3cb733","navMembers":[{"kind":"class","title":"Classes","summary":"All documented classes."},{"kind":"external","title":"Externals","summary":"All documented external members."},{"kind":"global","title":"Globals","summary":"All documented globals."},{"kind":"mixin","title":"Mixins","summary":"All documented mixins."},{"kind":"interface","title":"Interfaces","summary":"All documented interfaces."},{"kind":"module","title":"Modules","summary":"All documented modules."},{"kind":"namespace","title":"Namespaces","summary":"All documented namespaces."},{"kind":"tutorial","title":"Tutorials","summary":"All available tutorials."}],"footer":"","copyright":"FooDoc Copyright Â© 2016 The contributors to the JSDoc3 and FooDoc projects.","linenums":true,"collapseSymbols":false,"inverseNav":true,"inlineNav":false,"outputSourceFiles":true,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"linenum, longname, version, since","search":true,"favicon":"favicon.ico","stylesheets":[],"scripts":[],"monospaceLinks":true,"cleverLinks":true};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand branding-logo" href="index.html" style="background-image: url(img/logo.png);">
					Spotify Library.js
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Globals<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="global.html#AdditionalTypes">AdditionalTypes</a></li>
											<li><a href="global.html#AlbumGroups">AlbumGroups</a></li>
											<li><a href="global.html#ArtistAlbumsOptions">ArtistAlbumsOptions</a></li>
											<li><a href="global.html#Attributes">Attributes</a></li>
											<li><a href="global.html#CategoryOptions">CategoryOptions</a></li>
											<li><a href="global.html#ContextURI">ContextURI</a></li>
											<li><a href="global.html#FeaturedOptions">FeaturedOptions</a></li>
											<li><a href="global.html#FollowingArtistOptions">FollowingArtistOptions</a></li>
											<li><a href="global.html#LimitOptions">LimitOptions</a></li>
											<li><a href="global.html#ModifyOptions">ModifyOptions</a></li>
											<li><a href="global.html#PlaylistOptions">PlaylistOptions</a></li>
											<li><a href="global.html#PlaylistTracksOptions">PlaylistTracksOptions</a></li>
											<li><a href="global.html#RecentOptions">RecentOptions</a></li>
											<li><a href="global.html#RecommendedOptions">RecommendedOptions</a></li>
											<li><a href="global.html#RepeatStates">RepeatStates</a></li>
											<li><a href="global.html#SearchOptions">SearchOptions</a></li>
											<li><a href="global.html#SeedOptions">SeedOptions</a></li>
											<li><a href="global.html#StartOptions">StartOptions</a></li>
											<li><a href="global.html#Status">Status</a></li>
											<li><a href="global.html#TimeRange">TimeRange</a></li>
											<li><a href="global.html#UpdatePlaylistOptions">UpdatePlaylistOptions</a></li>
											<li><a href="global.html#UserTopOptions">UserTopOptions</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_class.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="Album.html">Album</a></li>
											<li><a href="AlbumManager.html">AlbumManager</a></li>
											<li><a href="ApiError.html">ApiError</a></li>
											<li><a href="Artist.html">Artist</a></li>
											<li><a href="ArtistManager.html">ArtistManager</a></li>
											<li><a href="Audio.html">Audio</a></li>
											<li><a href="AudioManager.html">AudioManager</a></li>
											<li><a href="Base.html">Base</a></li>
											<li><a href="CategoryManager.html">CategoryManager</a></li>
											<li><a href="Episode.html">Episode</a></li>
											<li><a href="EpisodeManager.html">EpisodeManager</a></li>
											<li><a href="HTTPError.html">HTTPError</a></li>
											<li><a href="PlayerManager.html">PlayerManager</a></li>
											<li><a href="Playlist.html">Playlist</a></li>
											<li><a href="PlaylistManager.html">PlaylistManager</a></li>
											<li><a href="Show.html">Show</a></li>
											<li><a href="ShowManager.html">ShowManager</a></li>
											<li><a href="Spotify.html">Spotify</a></li>
											<li><a href="Track.html">Track</a></li>
											<li><a href="TrackManager.html">TrackManager</a></li>
											<li><a href="User.html">User</a></li>
											<li><a href="UserManager.html">UserManager</a></li>
											<li><a href="Util.html">Util</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">managers/Playlist.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">const qs = require('querystring');
const Playlist = require('../structures/Playlist.js');
const Track = require('../structures/Track.js');

const API = 'https://api.spotify.com/v1/playlists';
const HTTPError = require('../HTTPError.js');
const ApiError = require('../ApiError');

class PlaylistManager {
  /**
   * Manages spotify playing.
   * @param {Spotify} spotify - The spotify client.
   */
  constructor(spotify) {
    /**
     * The spotify client.
     * @type {Spotify}
     */
    this.spotify = spotify;
  }

  /**
   * Get a playlist owned by a Spotify user.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {PlaylistOptions} options
   * @returns {Promise&lt;Playlist|HTTPError|ApiError>}
   */
  get(id, { types = ['track'], fields } = {}) {
    const options = qs.stringify({
      types: types.join(','),
      fields,
    });

    const path = API + '/' + id + '?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const playlist = new Playlist(this.spotify, body);
                return resolve(playlist);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Change a playlist's name and public/private state. (The user must, of course, own the playlist.)
   * @param {string} id - The Spotify ID of the playlist.
   * @param {ModifyOptions} options
   * @returns {Promise&lt;Status|HTTPError|ApiError>}
   */
  modify(id, { name, public: state, collaborative, description } = {}) {
    const body = {
      name,
      public: state,
      collaborative,
      description,
    };

    const path = API + '/' + id;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'put',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (response.status == 200) {
              resolve({ status: response.status });
            } else if (body) {
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Either reorder or replace items in a playlist depending on the request's parameters.
   * @param {string[]} id - The Spotify ID of the playlist.
   * @param {UpdatePlaylistOptions} options
   * @returns {Status|HTTPError|ApiError}
   */
  update(id, { uris, start, before, length, snapshot }) {
    const options = qs.stringify({
      uris,
    });

    const body = {
      range_start: start,
      insert_before: before,
      range_length: length,
      snapshot_id: snapshot,
    };

    const path = API + '/' + id + '/tracks?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'put',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 201) {
                return resolve({
                  status: response.status,
                  snapshot: body.snapshot_id,
                });
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Get full details of the items of a playlist owned by a Spotify user.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {PlaylistTracksOptions} options
   * @returns {Promise&lt;Track[]|HTTPError|ApiError>}
   */
  tracks(id, { types = ['track'], fields, limit = 20, offset = 0 } = {}) {
    const options = qs.stringify({
      types: types.join(','),
      fields,
      limit,
      offset,
    });

    const path = API + '/' + id + '/tracks?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const tracks = body.items.map((t) => {
                  const track = new Track(this.spotify, t);
                  Object.assign(track, track.track);
                  delete track.track;
                  return track;
                });
                return resolve(tracks);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Add one or more items to a user's playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {ContextURI|ContextURI[]} uris - A list of Spotify URIs to add, can be track or episode URIs. Maximum: 100
   * @param {number} [position=0] - The position to insert the items, a zero-based index.
   * @returns {Promise&lt;Status|HTTPError|ApiError>}
   */
  add(id, uris, position = 0) {
    const body = {
      uris: Array.isArray(uris) ? uris.join(',') : uris,
      position,
    };

    const path = API + '/' + id + '/tracks';

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'post',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 201) {
                resolve({ snapshot: body.snapshot_id });
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Remove one or more items from a user's playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {ContextURI|ContextURI[]} uris - A list of Spotify URIs to remove, can be track or episode URIs. Maximum: 100
   * @param {string} [snapshot] - The playlist's snapshot ID against which you want to make the changes.
   * @returns {Promise&lt;Status|HTTPError|ApiError>}
   */
  remove(id, uris, snapshot) {
    const body = {
      uris: Array.isArray(uris) ? uris.join(',') : uris,
      snapshot,
    };

    const path = API + '/' + id + '/tracks';

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'delete',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                resolve({ snapshot: body.snapshot_id });
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Get a list of the playlists owned or followed by the current Spotify user.
   * @param {string} [id] - The user's Spotify user ID - if not provided it will default to the current user.
   * @param {LimitOptions} options
   * @returns {Promise&lt;Playlist[]|HTTPError|ApiError>}
   */
  users(id, { limit = 20, offset = 0 } = {}) {
    const options = qs.stringify({
      limit,
      offset,
    });

    let path;

    if (!id) {
      path = 'https://api.spotify.com/v1/me/playlists?' + options;
    } else {
      path = 'https://api.spotify.com/v1/users/' + id + '/playlists?' + options;
    }

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const playlists = body.items.map(
                  (p) => new Playlist(this.spotify, p)
                );
                return resolve(playlists);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Add the current user as a follower of a playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {boolean} [state=true] -  If the playlist will be included in user's public playlists.
   * @returns {Promise&lt;Status|HTTPError|ApiError>}
   */
  follow(id, state = true) {
    const path = API + '/' + id + '/followers';

    const body = {
      public: state,
    };

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'put',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                resolve({ status: response.status });
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Remove the current user as a follower of a playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @returns {Promise&lt;Status|HTTPError|ApiError>}
   */
  unfollow(id) {
    const path = API + '/' + id + '/followers';

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'delete',
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                resolve({ status: response.status });
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Check to see if one or more Spotify users are following a specified playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {string|string[]} users - A list of Spotify User IDs.
   * @returns {boolean[]|HTTPError|ApiError}
   */
  followers(id, users) {
    const options = qs.stringify({
      ids: Array.isArray(users) ? users.join(',') : users,
    });

    const path = API + '/' + id + '/followers/contains?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                return resolve(body);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Create a playlist for a Spotify user.
   * @param {string} id - The user's Spotify user ID.
   * @param {ModifyOptions} options
   * @returns {Promise&lt;Playlist|HTTPError|ApiError>}
   */
  create(id, { name, public: state, collaborative, description } = {}) {
    const body = {
      name,
      public: state,
      collaborative,
      description,
    };

    const options = qs.stringify({ user_id: id });
    /* prettier-ignore */
    const path = 'https://api.spotify.com/v1/users/' + id + '/playlists?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
          method: 'post',
          body,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 201) {
                const playlist = new Playlist(this.spotify, body);
                return resolve(playlist);
              }
              reject(new ApiError(body.error));
            }

            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Get a list of Spotify featured playlists.
   * @param {FeaturedOptions} [options]
   * @returns {Promise&lt;Playlist[]|HTTPError|ApiError>}
   */
  featured({ limit = 20, locale, offset = 0, timestamp } = {}) {
    const opts = {
      limit,
      locale,
      offset,
    };

    if (timestamp) {
      opts['timestamp'] = timestamp;
    }

    const options = qs.stringify(opts);
    /* prettier-ignore */
    const path = 'https://api.spotify.com/v1/browse/featured-playlists?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const playlists = body.playlists.items.map(
                  (p) => new Playlist(this.spotify, p)
                );
                return resolve(playlists);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Get a list of Spotify playlists tagged with a particular category.
   * @param {string} id - The Spotify category ID for the category.
   * @param {LimitOptions} options
   * @returns {Promise&lt;Playlist[]|HTTPError|ApiError>}
   */
  categories(id, { limit = 20, offset = 0 } = {}) {
    const options = qs.stringify({
      limit,
      offset,
    });

    /* prettier-ignore */
    const path = 'https://api.spotify.com/v1/browse/categories/' + id + '/playlists?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const playlists = body.playlists.items.map(
                  (p) => new Playlist(this.spotify, p)
                );
                return resolve(playlists);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }

  /**
   * Get the current image associated with a specific playlist.
   * @param {string} id - The Spotify ID of the playlist.
   * @param {string} [image] - The Base64 image encoded to upload as cover art.
   * @returns {Promise&lt;Image|Status|HTTPError|ApiError>}
   */
  cover(id, image) {
    const path = API + '/' + id + '/images';
    let opts = {
      options: {
        headers: {
          'Content-Type': 'application/json',
        },
      },
      path,
    };

    if (image) {
      opts.options.headers['Content-Type'] = 'image/jpeg';
      opts['body'] = image;
      opts['method'] = 'put';
    }

    return new Promise((resolve, reject) => {
      this.spotify.util.fetch(opts).then((response) => {
        this.spotify.util.toJson(response).then((body) => {
          if (body) {
            if (response.status == 200) {
              return resolve(body);
            } else if (body.error) {
              reject(new ApiError(body.error));
            }
          } else if (response.status == 200) {
            return resolve({ status: response.status });
          }

          reject(new HTTPError(response));
        });
      });
    });
  }

  /**
   * Get Spotify catalog information about playlists.
   * @param {string} query - Your search query.
   * @param {SearchOptions} options
   * @returns {Promise&lt;Playlist[]|HTTPError|ApiError>}
   */
  search(query, { external = false, limit = 20, offset = 0 } = {}) {
    const opts = {
      q: query,
      type: 'playlist',
      limit,
      offset,
    };

    if (external) {
      opts['include_external'] = 'audio';
    }

    const options = qs.stringify(opts);
    const path = 'https://api.spotify.com/v1/search?' + options;

    return new Promise((resolve, reject) => {
      this.spotify.util
        .fetch({
          path,
        })
        .then((response) => {
          this.spotify.util.toJson(response).then((body) => {
            if (body) {
              if (response.status == 200) {
                const playlists = body.playlists.items.map(
                  (p) => new Playlist(this.spotify, p)
                );
                return resolve(playlists);
              }
              reject(new ApiError(body.error));
            }
            reject(new HTTPError(response));
          });
        });
    });
  }
}

module.exports = PlaylistManager;

/**
 * @typedef {Object} PlaylistOptions
 * @property {string} [types=['track']] - The types that the client supports. (track, episode)
 * @property {string} [fields] - Filters for the query, a list of the fields to return. If omitted, all fields are returned.
 */

/**
 * @typedef {PlaylistOptions} PlaylistTracksOptions
 * @property {number} [limit=20] - The maximum number of items to return. Minimum: 1. Maximum: 50.
 * @property {number} [offset=0] - The index of the first item to return.
 */

/**
 * @typedef {Object} FeaturedOptions
 * @property {number} [limit=20] - The maximum number of items to return. Minimum: 1. Maximum: 50.
 * @property {string} [locale] - The desired language, consisting of a lowercase ISO 639-1 language code and an uppercase ISO 3166-1 alpha-2 country code, joined by an underscore. For example: es_MX.
 * @property {number} [offset=0] - The index of the first item to return.
 * @property {string} [timestamp] - A timestamp in ISO 8601 format: yyyy-MM-ddTHH:mm:ss. Use this parameter to specify the user's local time to get results tailored for that specific date and time in the day. If not provided, the response defaults to the current UTC time.
 */

/**
 * @typedef {Object} ModifyOptions
 * @property {string} name - The new name for the playlist.
 * @property {boolean} public - If true the playlist will be public, if false it will be private.
 * @property {boolean} collaborative - If true, the playlist will become collaborative and other users will be able to modify the playlist in their Spotify client.
 * @property {string} description - Value for playlist description.
 */

/**
 * @typedef {Object} UpdatePlaylistOptions
 * @property {ContextURI[]} [uris] - A list of Spotify URIs to set, can be track or episode URIs.
 * @property {number} [start] - The position of the first item to be reordered.
 * @property {number} [before] - The position where the items should be inserted. To reorder the items to the end of the playlist, simply set insert_before to the position after the last item.
 * @property {number} [length=1] - The amount of items to be reordered.
 * @property {string} [snapshot] - The playlist's snapshot ID against which you want to make the changes.
 */
</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">FooDoc Copyright Â© 2016 The contributors to the JSDoc3 and FooDoc projects.</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on 5th Jun 2022 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->